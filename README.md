# rollup-ns

The ES6 to global namespace code transformation utility.

**Rollup-ns** is a node command producing a single (rolled-up) Namespace'd source code from the source ES6 modules.

## Why?

To support single-file namespace organized module output from the ES6 modularized solution. While transpiling and module bundling can solve much but this is not addressable by any of these tools. This scenario is not supported by the typescript compiler, and bundle tools like *babel* or *rollup*.

**rollup-ns** solves this scenario with custom source file transformation and module imports aware target namespace source code building. 

## How it works?

* rollup-ns reads all the ES6 modules in the given directory and subdirectories.
* changes original ES6 imports to namespace type imports.
* generates one single file containing the namespace organized modules.

*Note*: rollup-ns never changes the original sources but always rewrite the *single* output file. If you are customizing the generated namespaces use declaration merging and never make changes to the generated file.

## Configuration

Rollup-ns supports configuring the source folder, the target file and namespace. It also has configuration option for ignoring files (such as test files, or other support files) from the generated output.

**rollup-ns.config.js**

```javascript
/*
 * rollup-ns configuration.
 */
module.exports = {
	//set the target file 
	target: './generated/out.ts',

	//sets the target namespace 
	targetNs: 'Target.Namespace',

	//sets the source directory where the source es6 modules are located
	src: '../source/directory/',

	//enable/disable the target prettier.
	pretty: true,

	//excluded files...
	exclude: [
		//ignore the ES6 module index file (exports)
		'**/**/index.ts',

		//ignore the polyfill module.
		'**/**/polyfills.ts',

		//exclude all spec
		'**/*.[s|S]pec.ts',

		//exclude all test
		'**/*.[t|T]est.ts',

		//exclude all js files.
		'**/*.js',
	],
};
```

## Source Limitations

1. global module augmentation with ES6 *declare module* is not supported. 

To declare an "*extension*" such as Array or Window extensions the original ES6 module must not export any type or namespace and it must not declare the global module.

Instead define the module as the following:

    interface Array<T>;
    {
        extend():void;
    }

    extend():void
    {

    }

    array.prototype.extend = extend;

2. import * as 'es6-namespace-name' module import is not supported. 
 
**rollup-ns** needs *named* imports like this: 

    import { TypeName } from 'module';

where the imported *module* defines the type like this:

    export type TypeName = 'a' | 'b' | 'c';

3. imports from re-exporting modules are not supported.

## Example


**Basic source files**

./ClassA.ts
```typescript
import { EnumA } from './EnumA';


export class ClassA {
    enumField: EnumA;
}
```

./EnumA.ts
```typescript
export enum EnumA {
    A,
    B,
    C
}
```

./SubFolder/ClassB.ts
```typescript
import { ClassA } from '../ClassA';
import { EnumB } from './EnumB';

export class ClassB extends ClassA {
    subEnum: EnumB;
}
```

./SubFolder/EnumB.ts
```typescript
export enum EnumB {
    A,
    B,
    C
}
```


**Generated**

The generated single output file using *Samples.Basic* target namespace.

```typescript
//this file has been generated by a tool
//#region EnumA.ts
namespace Samples.Basic
{
export enum EnumA {
    A,
    B,
    C
}

}
//#endregion EnumA.ts
//#region ClassA.ts
namespace Samples.Basic
{

export class ClassA {
    enumField: EnumA;
}
}
//#endregion ClassA.ts
//#region EnumB.ts
namespace Samples.Basic.SubFolder
{

export enum EnumB {
    A,
    B,
    C
}

}
//#endregion EnumB.ts
//#region ClassB.ts
namespace Samples.Basic.SubFolder
{

export class ClassB extends ClassA {
    subEnum: EnumB;
}

}
//#endregion ClassB.ts
```