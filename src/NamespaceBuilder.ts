import fs = require("fs");
import prettier = require("prettier");
import { Namespace } from './Namespace';
import { Namespaces } from "./Namespaces";
import { Module } from "./Module";
import { Config } from './Config';
/**
 * defines the namespace builder.
 * It reads and resolves {@link Namespace} with their {@link Module} dependencies
 */
export class NamespaceBuilder {
    /**
     * all the modules directly under this {@link Namespace}.
     */
    modules: {
        [modulePath: string]: Module;
    } = {};
    /**
     * the root namespaces
     */
    rootNamespaces: Namespaces = {
        ["global"]: new Namespace("global")
    };
    /**
     * gets the type map
     */
    typeMap: { [typeName: string]: Module | Module[] } = {};

    /**
     * finds the module namespace
     * @param modulePath
     * @return  {Namespace | undefined }
     */
    findModuleNs(modulePath: string): Namespace | undefined {
        const moduleEntry = this.modules[modulePath];
        if (moduleEntry)
            return moduleEntry.ns;
        return undefined;
    }

    /**
     * gets the namespace for the given directory and file.
     * @param fullname
     */
    getNamespace(fullname: string): Namespace {
        const names = fullname.split(".");
        let ns: Namespace = this.rootNamespaces[fullname];
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            if (i === 0) {
                ns = this.rootNamespaces[name];
                if (!ns) {
                    ns = new Namespace(name);
                    this.rootNamespaces[name] = ns;
                }
            }
            else {
                let child = ns!.namespaces[name];
                if (!child) {
                    child = new Namespace(name, ns);
                    ns.namespaces[name] = child;
                }
                ns = child;
            }
        }
        return ns;
    }

    /**
     * Resolves all augmentations in a module (such as declare module '../CanvasTable')
     */
    resolveDeclareModules() {
        for (const key in this.modules) {
            const m = this.modules[key];
            m.resolveDeclareModules(this);
        }
    }

    /**
     * resolves all imports of a module, connects namespaces to those and sets the order
     */
    resolveImports() {
        //resolve the imports
        for (const key in this.modules) {
            const m = this.modules[key];
            m.resolveImports(this);
        }
        //debugger;
    }

    async write(config: Config): Promise<void> {
        let fd: number;
        // Open the file
        try {
            fd = fs.openSync(config.target, "w");
        }
        catch (e) {
            console.warn(e);
            console.warn('writing out.ts instead');
            fd = fs.openSync('out.ts', "w");
        }
        fs.writeFileSync(fd, "//this file has been generated by a tool\n");
        //get all the module keys
        const modules = Object.keys(this.modules).map(key => this.modules[key]);
        //write the modules to the output
        this.writeModules(fd, modules);
        // Force the file to be flushed
        fs.fdatasync(fd, err => {
            if (err)
                console.warn(err);
        });
        fs.close(fd, err => {
            if (err)
                console.warn(err);
        });

        if (config.pretty) {
            console.log(`pretty ${config.target}.`);
            await prettier
                .resolveConfig(config.target, {
                    useCache: true
                })
                .then(c => {
                    let source = fs.readFileSync(config.target, { encoding: "utf-8" });
                    source = prettier.format(source, {
                        ...c,
                        filepath: config.target
                    });
                    fs.writeFileSync(config.target, source, { encoding: "utf-8" });
                });
        }
    }

    /**
     * Writes modules to the disk.
     * @param fd The file descriptor to append the module into.
     * @param modules The array of the modules to write.
     */
    writeModules(fd: number, modules: Module[]): void {
        //find the first module which not written and has is no target

        let mergeClass = false;

        while (modules.length > 0) {
            const moduleIndex = modules
                .sort((a, b) => {
                    return a.ns.fullName.localeCompare(b.ns.fullName);
                })
                .findIndex(moduleToWrite => {
                    //get the module imports
                    const importedTypes = Object.keys(moduleToWrite.importedTypes);
                    const implementedTypes = moduleToWrite.implementedTypes;
                    const extendedTypes = moduleToWrite.extendedTypes;
                    const declaredModules = moduleToWrite.declaredModules;
                    //if the module dependencies has been satisfied we can write the module to the output.
                    //with typescript namespaces extended and implemented modules must be defined before the usage.

                    //when using declaration merging the parent class must be written.
                    const parentClassStatisfied = modules.every(m => {
                        return m.exportedTypes.filter(t => t.typeKind === 'class').every(t => {
                            return m.ns.fullName + '.' + t.typeName !== moduleToWrite.ns.fullName;
                        });
                    });

                    const importStatisifed = importedTypes.every(importedType => {
                        //all imported types are satisfied                            

                        const importedTypeModuleEntry = moduleToWrite.importedTypes[importedType];
                        //all imports has been already statisfied previously.
                        const importExplicitlyStatisfied = modules.every(a => a !== importedTypeModuleEntry.module);
                        //imported module is in the same namespace or parent namespace...
                        //const importImplicitlyStatisfied = moduleToWrite.ns == importedTypeModuleEntry.ns;
                        return importExplicitlyStatisfied;// || importImplicitlyStatisfied;
                    });

                    const implementStatisfied = implementedTypes.length === 0 || (implementedTypes.every(implementedType => {
                        //all implemented types are satisfied
                        //get the implementedModule import
                        const implementedTypeModuleEntry = moduleToWrite.importedTypes[implementedType];
                        if (implementedTypeModuleEntry) {
                            //in case it is defined it is an external dependency so check if already written
                            return modules.every(a => a !== implementedTypeModuleEntry.module);
                        }
                        else {
                            //otherwise the dependency is internal...
                            return true;
                        }
                    }));

                    const extendStatisfied = extendedTypes.length === 0 || (extendedTypes.every(extendedType => {
                        //all extended types are satisfied
                        //gets the extendedModule import
                        const extendedTypeModuleEntry = moduleToWrite.importedTypes[extendedType];
                        if (extendedTypeModuleEntry) {
                            //in case it is defined it is an external dependency so check if already written
                            return modules.every(a => a !== extendedTypeModuleEntry.module);
                        }
                        else {
                            //otherwise the dependency is internal...
                            return true;
                        }
                    }));

                    const declareStatisfied = declaredModules.length === 0 || (declaredModules.every(declaredModule => {
                        return modules.every(m => m !== declaredModule);
                    }));

                    if (mergeClass) {
                        return moduleToWrite.mergeClass;
                    } else {
                        const allStatisfied = parentClassStatisfied && importStatisifed && implementStatisfied && extendStatisfied && declareStatisfied;
                        return allStatisfied;
                    }
                });
            if (moduleIndex === -1 && !mergeClass) {
                //reset the merge class flag
                mergeClass = true;
                continue;
            }
            if (moduleIndex === -1 && mergeClass === true) {
                //in this case none of the modules can be statisfied.
                //theoretically it is possible because of bug in the rollup-ns and circular dependenency in the modules.
                //the circular dependency most probably also an error by the tsc compiler.
                //the bugs root cause can miss-identified import/extends/implements detection.
                debugger;
                console.log("unresolved modules");
                const me = modules.sort((a, b) => a.modulePath.localeCompare(b.modulePath));
                me.forEach(m => {
                    console.log(m.modulePath);
                });
                throw new Error("module resolve order has been failed");
            }
            const m = modules[moduleIndex];
            //write out the module
            m.writeTo(fd);
            //finally remove the actually written module from the module list.
            const index = modules.indexOf(m, 0);
            if (index > -1) {
                modules.splice(index, 1);
            }
            //reset the merge class flag
            mergeClass = false;
        }
    }
}
